2025/3/7
    modify: 修改脉冲定时器中断模式---为实现使步进电机转动固定圈数。
    error: pulse_cnt  float类型不能够准确的去反应脉冲-可能导致溢出等错误，建议 ！！修改！！！

2025/3/8
    test：测试了脉冲定时器中断模式，可以正常使用。
    modify： 修改了转固定圈数的方法
    error:  新方法在中断中运行，导致脉冲计数不准确

    新方法的脉冲计数时间：
            开始 10:42:21.534   
            结束 10:42:35.240
            时间差：13.706s 左右
    只有脉冲计数的时间：
            开始 10:50:11.417
            结束 10:50:12.418
            时间差：1s 左右
    解决办法：
        将计数放到while中。
2025/3/9
    task：昨天将，脉冲计算放到了while中，可以进行正常计数，精度较高。
    今天计划，写一份关于tmc2209的串口驱动控制。

    error: 串口不能通过发送命令驱动电机运行，只能够通过串口进行配置电机参数。


2025/3/19
    新板子到了，开始调试。

2025/3/21
    加了usb的发送和接收的功能，内容不完整。
    加了舵机的初始化功能，并测试
2025/3/22
    修正了舵机的打脚，并测试
    添加按键功能（长短按）--使用到了一个tim1定时器当作时基
    按键功能长短按--通过key_led_test实验成功
    添加了步进电机的一个对象，（考虑是否通过一个tim的不同的channel去控制两个电机，这样步进电机的移动速度相同）
    修改了步进电机的函数，尚未测试
2025/3/23
    由于步进电机的使能引脚设置为了 set导致不能启动，因为tmc2209的en脚是低电平启动的
    测试了步进电机的运行，边步进电机，126圈1100cnt 才可以走完全程，内步进电机，123圈 1000cnt 才可以走完全程
    写了按键的步进电机测试功能
    将一部分文件中的宏 放到了h文件中
2025/3/25
    准备将舵机的运行速度放慢，修改了gtipper文件，但是效果很差，基本上没有变慢，暂时没有找到原因。
        经过灯光反转测试，发现灯光反转测试是正确的，可能是封装的函数有问题。

2025/5/4
    修改了串口部分代码：DEBUG.C  & UARTFACE.C 暂未调试
2025/5/5
    经过计算通过摄像头拍摄，将整个画面假设成一个xy坐标系
    （0,y）---------------(x,y)
       |                    |
       |                    |
       |                    |
       |                    |
       |                    |
    （0,0）--------------(x,0)

    其中，物料是在整个坐标系中的任意一点，通过坐标转换把对应的
    物料坐标转换为步进电机的  圈数和脉冲数（这样子还是会有一些误差可能是由于机械抖动和转动时器件之间有间隙导致的）
    所以需要用摄像头进行实施监控，再利用pid使物料坐标和当前的爪子的坐标进行作差然后使爪子可以准确的去抓取物料。
    具体的转换方式为:
        “N内 = X1/X * 123”
        “N外 = Y1/Y * 126”
    这样子会有一些机械误差导致的抓取不准
    进行pid操作的
        err内 = （x-x1）
        err外 = （y-y1）
        pid = p * (err)  + i * (err - last_err) + d * (err+las_las_err - 2* last_err)
    将pid的值变为需要转的cnt或圈数 乘一个系数 赋值给对应的 步进电机，这样就可以控制对应的步进电机，运行了。

    校验码的计算方法
        uint8_t  calc_checksum ^= Uart6_RxBuffer[i];
        其中Uart6_RxBuffer[i]是数据内容的每一个字节
        计算校验码时不包括帧头、数据长度、校验码和帧尾

    串口数据帧：
        舵机：
        电机：
        xy坐标系:
            0xA5 | 0x04  | 0x00 0x00 0xFF 0XFF | 0xXX | 0x5B    --> x = 0  y = 255

2025/5/6

如何进行测试？
    通过单元测试 进行测试 看看是否可以正常运行 

测试 xy坐标系的数据帧
            数据内容： 类别（1），x坐标（2个字节），y坐标（2个字节）

            0xA5 | 0x04 | 0x03 | 0x00,0xff,0x00,0xff | 0x00 | 0x5B 
            0xA5 | 0x04 | 0x03 | 0x00,0x01,0x00,0xff | 0x00 | 0x5B 
            0xA5 | 0x04 | 0x03 | 0x00,0xff,0x00,0x01 | 0xfe | 0x5B 
            0xA5 | 0x04 | 0x03 | 0x00,0xff,0x00,0xff | 0x00 | 0x5B 

            {0x00,0xff,0x00,0xff},  // x= 255 y = 255   checksum 0
            {0x00,0x01,0x00,0xff},	// x = 1  y = 255   checksum 0
            {0x00,0xff,0x00,0x01},  // x = 255 y = 1    checksum 254
            {0x00,0x01,0x00,0x01},  // x = 1   y = 1    checksum 0

测试 舵机的数据帧

    数据内容：类别(1),舵机id(1),修改项(1),pwm占空比(1个字节)，角度(3个字节，前两个整数，最后一个小数 最后一个字节的范围是 0-9)， 方向（1字节）

    0xA5| 0x04| 0x01,0x00,0x07,0x64,0x09,0xc0,0x02,0x01,| 168 | 0x5B   //duty 100  156.2

    0xA5| 0x04| 0x01,0x00,0x02,0x09,0xc0,0x02,| 96 | 0x5B

    0xA5| 0x04| 0x01,0x00,0x04,0x01,| 100 | 0x5B

        三个修改项

            checksum = 168

            0x01 0x00  0x07(三个修改项) 
            0x64 占空比  (该数据需要除以1000才是真正的占空比)   ---> （可以转换成占空比 对应着角度  从 0 - 180   不同的id号 ， 角度不同）
            0x00 0x09 0xc0 0x02 (角度)  156  2    （0-360 ） （0-180）角度是按照不同舵机id来看的  现在我们这个ID用的都是 180°的舵机
            0x01 （方向）

        一个修改项   
            
            checksum = 96
            0x01 0x00  0x02(一个修改项) 
            0x00 0x09 0xc0 0x02 (角度)  156  2

            checksum = 100
            0x01 0x00  0x04 (一个修改项) 
            0x01 （方向）
舵机角度
        0.5ms--------------0度；
        1.0ms------------45度；
        1.5ms------------90度；
        2.0ms-----------135度；
        2.5ms-----------180度；
    占空比： 从 （25-> 125）  /1000   -> 对应的舵机
        0.5/20 = 0.025
        2.5/20 = 0.1250
    总周期时长是 20ms

测试 步进电机的数据帧

        数据内容：类别（1），步进电机id（1），修改项（1），速度(2个字节) --> 52--5250  (52最快-5250最慢)  
                  方向（1），圈数(3个字节，前2字节存整数)  ->  （不同的电机不同） （最大126  最大123）   后一个字节范围是 0-9

        0xA5| 0x04| 0x02,0x00,0x04, 0x01,| 4 | 0x5B //方向

        0xA5| 0x04| 0x02,0x00,0x08, 0x00,0x78,0x03,| 118 | 0x5B  //圈数 120.3

        0xA5| 0x04| 0x02,0x00,0x0C, 0x00,0x78,0x03, 0x14,0x82| 136 | 0x5B   // 圈数 120.3  速度 5250

这里是顺序：
    舵机数据解析：
        PWM占空比：直接读取第 3 个字节。
        角度：前两个字节为整数部分，第 3 个字节为小数部分，合成为浮点数。
        方向：读取第 7 个字节。
    步进电机数据解析：
        速度：读取第 3 和第 4 个字节（2 字节）。
        方向：读取第 5 个字节。
        圈数：前两个字节为整数部分，第 3 个字节为小数部分，合成为浮点数。
    XY 坐标数据解析：
        X 坐标：读取第 1 和第 2 个字节（2 字节）。
        Y 坐标：读取第 3 和第 4 个字节（2 字节）。



修改了数据解析的方式
        通过一个偏移量，提高读取数据的正确性
    

问题，现在还需要进行输出限幅

////
    现在将输出限制幅度 加上去了，准备测试

2025/5/7
    当使用printf重定向到串口时，由于keil没有勾选使用 miclib 导致printf重定向出错，程序卡死。
    取消后，程序可以正常运行。可以在外部搭建仿真环境去仿真，进行单元测试，判断是否可以数据是否可以正常运行。
    
    OPTION_PWM_FREQUENCY = (1 << 0),    // 位0
    OPTION_ANGLE = (1 << 1),            // 位1
    OPTION_DIRECTION = (1 << 2),        // 位2
    OPTION_SPEED = (1 << 3),            // 位3
    OPTION_CIRCLE = (1 << 4),           // 位4

    这个很重要，由于option填错了，导致我后续解析的数据有部分是错误的。
    而且顺序也很重要，否则数据和数据是对应不上的

    如果发现数据有错误，请检查是否数据帧的数据有问题，当数据帧发送的有问题时
会导致有一些错误，经检验，现在的数据解析流程是正确的。

就差xy进行运动轨迹拟合了，让xy坐标系和实际的实物的长短拟合，然后推算出需要走的圈数
